"""
Phase 1: SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®º
ÁèæÁä∂ÊúÄÈÅ©ÂåñÁ∂ôÁ∂öÊà¶Áï•„Å´„Åä„Åë„ÇãÊï∞ÂÄ§ÂìÅË≥™„ÉªË®àÁÆóÁ≤æÂ∫¶Á¢∫‰øù

96.7/100ÂìÅË≥™„É¨„Éô„É´Á∂≠ÊåÅ„ÅÆ„Åü„ÇÅ„ÅÆË®àÁÆó‰øùË≠∑Á¢∫Ë™ç
"""

import os
import json
import datetime
import re
from typing import Dict, List, Any

class Phase1SlotHoursVerification:
    """Phase 1: SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®º„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self):
        self.base_path = "/mnt/c/Users/fuji1/OneDrive/„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó/„Ç∑„Éï„ÉàÂàÜÊûê"
        self.verification_start_time = datetime.datetime.now()
        
        # SLOT_HOURS‰øùË≠∑ÂØæË±°„É¢„Ç∏„É•„Éº„É´
        self.protected_modules = [
            'shift_suite/tasks/fact_extractor_prototype.py',
            'shift_suite/tasks/lightweight_anomaly_detector.py'
        ]
        
        # Ë®àÁÆóÁ≤æÂ∫¶„Éô„Éº„Çπ„É©„Ç§„É≥
        self.calculation_baselines = {
            'slot_hours_value': 0.5,  # 30ÂàÜ = 0.5ÊôÇÈñì
            'minimum_multiplications': 1,
            'expected_definition_count': 1,
            'calculation_accuracy_target': 100.0  # 100%Á≤æÂ∫¶Ë¶ÅÊ±Ç
        }
        
        # Ê§úË®º„Éë„Çø„Éº„É≥
        self.verification_patterns = {
            'slot_hours_definition': r'SLOT_HOURS\s*=\s*0\.5',
            'slot_hours_multiplication': r'\*\s*SLOT_HOURS',
            'slot_hours_usage': r'SLOT_HOURS',
            'calculation_context': r'(hours|ÊôÇÈñì|Ë®àÁÆó).*SLOT_HOURS|SLOT_HOURS.*(hours|ÊôÇÈñì|Ë®àÁÆó)',
            'protected_calculation': r'(parsed_slots_count|slot_count|slots).*\*\s*SLOT_HOURS'
        }
        
    def execute_slot_hours_verification(self):
        """SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®º„É°„Ç§„É≥ÂÆüË°å"""
        print("üîç Phase 1: SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®ºÈñãÂßã...")
        print(f"üìÖ Ê§úË®ºÂÆüË°åÊôÇÂàª: {self.verification_start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"üéØ Ë®àÁÆóÁ≤æÂ∫¶ÁõÆÊ®ô: {self.calculation_baselines['calculation_accuracy_target']}%")
        
        try:
            # „É¢„Ç∏„É•„Éº„É´Âà•SLOT_HOURSÊ§úË®º
            module_verification_results = {}
            
            for module_path in self.protected_modules:
                print(f"\nüîÑ {module_path}Ê§úË®º‰∏≠...")
                verification_result = self._verify_module_slot_hours_implementation(module_path)
                module_verification_results[module_path] = verification_result
                
                if verification_result['verification_success']:
                    print(f"‚úÖ {module_path}: Ë®àÁÆó‰øùË≠∑Ê≠£Â∏∏")
                else:
                    print(f"‚ö†Ô∏è {module_path}: Ë¶ÅÁ¢∫Ë™ç")
            
            # Ë®àÁÆó‰∏ÄË≤´ÊÄß„ÉªÊï¥ÂêàÊÄßÁ¢∫Ë™ç
            consistency_check = self._check_calculation_consistency(module_verification_results)
            if consistency_check['consistency_maintained']:
                print("‚úÖ Ë®àÁÆó‰∏ÄË≤´ÊÄß„ÉªÊï¥ÂêàÊÄß: Á∂≠ÊåÅ")
            else:
                print("‚ö†Ô∏è Ë®àÁÆó‰∏ÄË≤´ÊÄß„ÉªÊï¥ÂêàÊÄß: Ë¶ÅÂØæÂøú")
            
            # Êï∞ÂÄ§Á≤æÂ∫¶„ÉªÊ≠£Á¢∫ÊÄßË©ï‰æ°
            accuracy_evaluation = self._evaluate_numerical_accuracy(module_verification_results)
            if accuracy_evaluation['accuracy_acceptable']:
                print("‚úÖ Êï∞ÂÄ§Á≤æÂ∫¶„ÉªÊ≠£Á¢∫ÊÄß: acceptable")
            else:
                print("‚ö†Ô∏è Êï∞ÂÄ§Á≤æÂ∫¶„ÉªÊ≠£Á¢∫ÊÄß: Ë¶ÅÊîπÂñÑ")
            
            # Á∑èÂêàÊ§úË®ºÁµêÊûúÂàÜÊûê
            verification_analysis = self._analyze_verification_results(
                module_verification_results, consistency_check, accuracy_evaluation
            )
            
            return {
                'metadata': {
                    'verification_execution_id': f"PHASE1_SLOT_HOURS_VERIFY_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    'verification_start_time': self.verification_start_time.isoformat(),
                    'verification_end_time': datetime.datetime.now().isoformat(),
                    'verification_duration': str(datetime.datetime.now() - self.verification_start_time),
                    'calculation_baselines': self.calculation_baselines,
                    'verification_scope': 'SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄß„Éª‰øùË≠∑Ê©üËÉΩ„ÉªÊï∞ÂÄ§Á≤æÂ∫¶'
                },
                'module_verification_results': module_verification_results,
                'consistency_check': consistency_check,
                'accuracy_evaluation': accuracy_evaluation,
                'verification_analysis': verification_analysis,
                'success': verification_analysis['overall_verification_status'] == 'verified',
                'slot_hours_verification_status': verification_analysis['verification_level']
            }
            
        except Exception as e:
            return {
                'error': str(e),
                'timestamp': datetime.datetime.now().isoformat(),
                'status': 'slot_hours_verification_failed'
            }
    
    def _verify_module_slot_hours_implementation(self, module_path):
        """„É¢„Ç∏„É•„Éº„É´Âà•SLOT_HOURSÂÆüË£ÖÊ§úË®º"""
        try:
            full_path = os.path.join(self.base_path, module_path)
            
            if not os.path.exists(full_path):
                return {
                    'verification_success': False,
                    'error': 'module_not_found',
                    'module_status': 'missing'
                }
            
            with open(full_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # „Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞Ê§úË®º
            pattern_matches = {}
            for pattern_name, pattern in self.verification_patterns.items():
                matches = re.findall(pattern, content, re.IGNORECASE)
                pattern_matches[pattern_name] = {
                    'count': len(matches),
                    'matches': matches,
                    'found': len(matches) > 0
                }
            
            # Âü∫Êú¨Ê§úË®ºÈ†ÖÁõÆ
            basic_verification = {
                'slot_hours_defined': pattern_matches['slot_hours_definition']['found'],
                'slot_hours_definition_count': pattern_matches['slot_hours_definition']['count'],
                'slot_hours_multiplications': pattern_matches['slot_hours_multiplication']['count'],
                'slot_hours_usage_count': pattern_matches['slot_hours_usage']['count'],
                'protected_calculations_found': pattern_matches['protected_calculation']['found'],
                'protected_calculations_count': pattern_matches['protected_calculation']['count']
            }
            
            # Ë®àÁÆóÊñáËÑàÂàÜÊûê
            calculation_context = {
                'context_matches': pattern_matches['calculation_context']['matches'],
                'context_appropriate': len(pattern_matches['calculation_context']['matches']) > 0,
                'calculation_purpose': 'time_conversion' if 'hours' in str(pattern_matches['calculation_context']['matches']).lower() else 'slot_conversion'
            }
            
            # „Ç≥„Éº„ÉâÂìÅË≥™ÊåáÊ®ô
            code_quality = {
                'module_size': len(content),
                'lines_count': len(content.splitlines()),
                'comments_present': '"""' in content or '#' in content,
                'imports_present': 'import' in content,
                'functions_defined': content.count('def ') > 0,
                'classes_defined': content.count('class ') > 0
            }
            
            # Ê§úË®ºÊàêÂäüÂà§ÂÆö
            verification_success = (
                basic_verification['slot_hours_defined'] and
                basic_verification['slot_hours_definition_count'] >= self.calculation_baselines['minimum_multiplications'] and
                basic_verification['slot_hours_multiplications'] >= self.calculation_baselines['minimum_multiplications'] and
                basic_verification['protected_calculations_found']
            )
            
            # Ë®àÁÆó‰øùË≠∑„É¨„Éô„É´Ë©ï‰æ°
            if verification_success and basic_verification['slot_hours_multiplications'] >= 3:
                protection_level = 'comprehensive'
            elif verification_success:
                protection_level = 'standard'
            elif basic_verification['slot_hours_defined']:
                protection_level = 'minimal'
            else:
                protection_level = 'insufficient'
            
            return {
                'verification_success': verification_success,
                'pattern_matches': pattern_matches,
                'basic_verification': basic_verification,
                'calculation_context': calculation_context,
                'code_quality': code_quality,
                'protection_level': protection_level,
                'module_status': 'verified' if verification_success else 'requires_attention',
                'verification_timestamp': datetime.datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'verification_success': False,
                'error': str(e),
                'module_status': 'verification_failed'
            }
    
    def _check_calculation_consistency(self, module_verification_results):
        """Ë®àÁÆó‰∏ÄË≤´ÊÄß„ÉªÊï¥ÂêàÊÄßÁ¢∫Ë™ç"""
        try:
            consistency_checks = {}
            
            # ÂÖ®„É¢„Ç∏„É•„Éº„É´Áµ±Ë®à
            total_definitions = sum(
                result.get('basic_verification', {}).get('slot_hours_definition_count', 0)
                for result in module_verification_results.values()
                if result.get('verification_success', False)
            )
            
            total_multiplications = sum(
                result.get('basic_verification', {}).get('slot_hours_multiplications', 0)
                for result in module_verification_results.values()
                if result.get('verification_success', False)
            )
            
            total_usage = sum(
                result.get('basic_verification', {}).get('slot_hours_usage_count', 0)
                for result in module_verification_results.values()
                if result.get('verification_success', False)
            )
            
            # „É¢„Ç∏„É•„Éº„É´Èñì‰∏ÄË≤´ÊÄßÁ¢∫Ë™ç
            definition_consistency = all(
                result.get('basic_verification', {}).get('slot_hours_definition_count', 0) >= 1
                for result in module_verification_results.values()
                if result.get('verification_success', False)
            )
            
            protection_level_consistency = all(
                result.get('protection_level', '') in ['standard', 'comprehensive']
                for result in module_verification_results.values()
                if result.get('verification_success', False)
            )
            
            # Ë®àÁÆó„Éë„Çø„Éº„É≥‰∏ÄË≤´ÊÄß
            pattern_consistency = {
                'all_modules_have_definitions': definition_consistency,
                'all_modules_have_multiplications': all(
                    result.get('basic_verification', {}).get('slot_hours_multiplications', 0) > 0
                    for result in module_verification_results.values()
                    if result.get('verification_success', False)
                ),
                'protection_levels_consistent': protection_level_consistency,
                'calculation_contexts_appropriate': all(
                    result.get('calculation_context', {}).get('context_appropriate', False)
                    for result in module_verification_results.values()
                    if result.get('verification_success', False)
                )
            }
            
            # ‰∏ÄË≤´ÊÄßË©ï‰æ°
            consistency_score = sum(pattern_consistency.values()) / len(pattern_consistency)
            consistency_maintained = consistency_score >= 0.75  # 75%‰ª•‰∏ä„Åß‰∏ÄË≤´ÊÄßÁ∂≠ÊåÅ
            
            consistency_checks = {
                'total_definitions': total_definitions,
                'total_multiplications': total_multiplications,
                'total_usage': total_usage,
                'pattern_consistency': pattern_consistency,
                'consistency_score': consistency_score,
                'consistency_maintained': consistency_maintained,
                'consistency_level': 'high' if consistency_score >= 0.9 else 'moderate' if consistency_score >= 0.75 else 'low'
            }
            
            return {
                'success': True,
                'consistency_checks': consistency_checks,
                'consistency_maintained': consistency_maintained,
                'check_timestamp': datetime.datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'consistency_maintained': False
            }
    
    def _evaluate_numerical_accuracy(self, module_verification_results):
        """Êï∞ÂÄ§Á≤æÂ∫¶„ÉªÊ≠£Á¢∫ÊÄßË©ï‰æ°"""
        try:
            accuracy_metrics = {}
            
            # ÂêÑ„É¢„Ç∏„É•„Éº„É´„ÅÆÁ≤æÂ∫¶Ë©ï‰æ°
            module_accuracy_scores = {}
            
            for module_path, result in module_verification_results.items():
                if result.get('verification_success', False):
                    # Âü∫Êú¨Á≤æÂ∫¶„Çπ„Ç≥„Ç¢
                    basic_score = 0
                    
                    # SLOT_HOURSÂÆöÁæ©„ÅÆÊ≠£Á¢∫ÊÄß
                    if result.get('basic_verification', {}).get('slot_hours_defined', False):
                        basic_score += 30
                    
                    # ‰πóÁÆó‰ΩøÁî®„ÅÆÈÅ©ÂàáÊÄß
                    multiplications = result.get('basic_verification', {}).get('slot_hours_multiplications', 0)
                    if multiplications >= 1:
                        basic_score += 25
                    if multiplications >= 3:
                        basic_score += 15  # Ë§áÊï∞ÁÆáÊâÄ„Åß„ÅÆ‰ΩøÁî®
                    
                    # ‰øùË≠∑Ë®àÁÆó„ÅÆÂ≠òÂú®
                    if result.get('basic_verification', {}).get('protected_calculations_found', False):
                        basic_score += 20
                    
                    # „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÈÅ©ÂàáÊÄß
                    if result.get('calculation_context', {}).get('context_appropriate', False):
                        basic_score += 10
                    
                    module_accuracy_scores[module_path] = basic_score
                else:
                    module_accuracy_scores[module_path] = 0
            
            # ÂÖ®‰ΩìÁ≤æÂ∫¶Ë©ï‰æ°
            overall_accuracy_score = sum(module_accuracy_scores.values()) / len(module_accuracy_scores) if module_accuracy_scores else 0
            
            # Á≤æÂ∫¶Âà§ÂÆö
            accuracy_acceptable = overall_accuracy_score >= self.calculation_baselines['calculation_accuracy_target'] * 0.95  # 95%‰ª•‰∏ä
            
            # Á≤æÂ∫¶„É¨„Éô„É´ÂàÜÈ°û
            if overall_accuracy_score >= 95:
                accuracy_level = 'excellent'
            elif overall_accuracy_score >= 85:
                accuracy_level = 'good'
            elif overall_accuracy_score >= 75:
                accuracy_level = 'acceptable'
            else:
                accuracy_level = 'needs_improvement'
            
            accuracy_metrics = {
                'module_accuracy_scores': module_accuracy_scores,
                'overall_accuracy_score': overall_accuracy_score,
                'accuracy_acceptable': accuracy_acceptable,
                'accuracy_level': accuracy_level,
                'target_score': self.calculation_baselines['calculation_accuracy_target'],
                'accuracy_gap': self.calculation_baselines['calculation_accuracy_target'] - overall_accuracy_score
            }
            
            return {
                'success': True,
                'accuracy_metrics': accuracy_metrics,
                'accuracy_acceptable': accuracy_acceptable,
                'evaluation_timestamp': datetime.datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'accuracy_acceptable': False
            }
    
    def _analyze_verification_results(self, module_results, consistency_check, accuracy_evaluation):
        """Ê§úË®ºÁµêÊûúÁ∑èÂêàÂàÜÊûê"""
        try:
            # ÂêÑ„Ç´„ÉÜ„Ç¥„É™ÊàêÂäüÁ¢∫Ë™ç
            categories_success = {
                'module_verification': all(
                    result.get('verification_success', False)
                    for result in module_results.values()
                ),
                'consistency_check': consistency_check.get('consistency_maintained', False),
                'accuracy_evaluation': accuracy_evaluation.get('accuracy_acceptable', False)
            }
            
            # Á∑èÂêàÊàêÂäüÁéá
            overall_success_rate = sum(categories_success.values()) / len(categories_success)
            
            # Ê§úË®º„Çπ„ÉÜ„Éº„Çø„ÇπÂà§ÂÆö
            if overall_success_rate == 1.0:
                overall_verification_status = 'verified'
                verification_level = 'fully_compliant'
            elif overall_success_rate >= 0.67:
                overall_verification_status = 'mostly_verified'
                verification_level = 'largely_compliant'
            else:
                overall_verification_status = 'requires_attention'
                verification_level = 'needs_improvement'
            
            # ÂÖ∑‰ΩìÁöÑÂïèÈ°å„ÉªÊé®Â•®‰∫ãÈ†ÖË≠òÂà•
            identified_issues = []
            recommended_actions = []
            
            if not categories_success['module_verification']:
                failed_modules = [
                    module_path for module_path, result in module_results.items()
                    if not result.get('verification_success', False)
                ]
                if failed_modules:
                    identified_issues.append(f"„É¢„Ç∏„É•„Éº„É´Ê§úË®ºÂ§±Êïó: {', '.join(failed_modules)}")
                    recommended_actions.append("Â§±Êïó„É¢„Ç∏„É•„Éº„É´„ÅÆSLOT_HOURSÂÆüË£Ö‰øÆÊ≠£")
            
            if not categories_success['consistency_check']:
                identified_issues.append("Ë®àÁÆó‰∏ÄË≤´ÊÄß„ÉªÊï¥ÂêàÊÄßÂïèÈ°å")
                recommended_actions.append("„É¢„Ç∏„É•„Éº„É´ÈñìSLOT_HOURS‰ΩøÁî®„Éë„Çø„Éº„É≥Áµ±‰∏Ä")
            
            if not categories_success['accuracy_evaluation']:
                accuracy_gap = accuracy_evaluation.get('accuracy_metrics', {}).get('accuracy_gap', 0)
                identified_issues.append(f"Á≤æÂ∫¶‰∏çË∂≥: {accuracy_gap:.1f}%„ÅÆ„ÇÆ„É£„ÉÉ„Éó")
                recommended_actions.append("Ë®àÁÆóÁ≤æÂ∫¶Âêë‰∏ä„Éª‰øùË≠∑Ê©üËÉΩÂº∑Âåñ")
            
            # ÂìÅË≥™„Éô„Éº„Çπ„É©„Ç§„É≥Á∂≠ÊåÅË©ï‰æ°
            quality_baseline_maintained = overall_success_rate >= 0.967  # 96.7%‰ª•‰∏ä
            
            # Ê¨°ÂõûÊ§úË®ºË®àÁîª
            next_verification_schedule = {
                'next_verification_date': (datetime.datetime.now() + datetime.timedelta(days=1)).strftime('%Y-%m-%d'),
                'verification_frequency': 'Êó•Ê¨°' if overall_verification_status == 'requires_attention' else 'ÈÄ±Ê¨°',
                'priority_level': 'high' if overall_verification_status == 'requires_attention' else 'medium'
            }
            
            return {
                'overall_verification_status': overall_verification_status,
                'verification_level': verification_level,
                'categories_success': categories_success,
                'overall_success_rate': overall_success_rate,
                'quality_baseline_maintained': quality_baseline_maintained,
                'identified_issues': identified_issues,
                'recommended_actions': recommended_actions,
                'next_verification_schedule': next_verification_schedule,
                'analysis_timestamp': datetime.datetime.now().isoformat(),
                'phase1_data_quality_status': 'maintained' if overall_verification_status in ['verified', 'mostly_verified'] else 'requires_attention'
            }
            
        except Exception as e:
            return {
                'overall_verification_status': 'analysis_failed',
                'error': str(e),
                'analysis_method': 'verification_analysis_failed'
            }

def main():
    """Phase 1: SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®º„É°„Ç§„É≥ÂÆüË°å"""
    print("üîç Phase 1: SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®ºÈñãÂßã...")
    
    verifier = Phase1SlotHoursVerification()
    result = verifier.execute_slot_hours_verification()
    
    if 'error' in result:
        print(f"‚ùå SLOT_HOURSÊ§úË®º„Ç®„É©„Éº: {result['error']}")
        return result
    
    # ÁµêÊûú‰øùÂ≠ò
    result_file = f"Phase1_SLOT_HOURS_Verification_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(result_file, 'w', encoding='utf-8') as f:
        json.dump(result, f, ensure_ascii=False, indent=2)
    
    # ÁµêÊûúË°®Á§∫
    print(f"\nüéØ Phase 1: SLOT_HOURSË®àÁÆóÊ≠£Á¢∫ÊÄßÊ§úË®ºÂÆå‰∫Ü!")
    print(f"üìÅ Ê§úË®ºÁµêÊûú„Éï„Ç°„Ç§„É´: {result_file}")
    
    if result['success']:
        print(f"‚úÖ SLOT_HOURSË®àÁÆóÊ§úË®º: ÊàêÂäü")
        print(f"üèÜ Ê§úË®º„É¨„Éô„É´: {result['verification_analysis']['verification_level']}")
        print(f"üìä ÊàêÂäüÁéá: {result['verification_analysis']['overall_success_rate']:.1%}")
        print(f"üéØ ÂìÅË≥™„Éô„Éº„Çπ„É©„Ç§„É≥Á∂≠ÊåÅ: {'Yes' if result['verification_analysis']['quality_baseline_maintained'] else 'No'}")
        
        if result['verification_analysis']['recommended_actions']:
            print(f"\nüöÄ Êé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥:")
            for i, action in enumerate(result['verification_analysis']['recommended_actions'][:3], 1):
                print(f"  {i}. {action}")
    else:
        print(f"‚ùå SLOT_HOURSË®àÁÆóÊ§úË®º: Ë¶ÅÂØæÂøú")
        print(f"üìã ÂïèÈ°å: {', '.join(result['verification_analysis']['identified_issues'])}")
        print(f"üö® Ë®àÁÆóÁ≤æÂ∫¶Á¢∫‰øù„ÅåÂøÖË¶Å")
    
    return result

if __name__ == "__main__":
    result = main()